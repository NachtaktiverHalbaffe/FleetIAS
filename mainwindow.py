"""
Filename: mainwindow.py
Version name: 1.0, 2021-07-22
Short description: callback functions for button presses. These are defined here so it wont get deleted
if mainwindow.py is regenerated by pyqt5-tools

(C) 2003-2021 IAS, Universitaet Stuttgart

"""
import cgitb

cgitb.enable(format="text")

import sys
import logging
from threading import Thread
from PySide6.QtWidgets import (
    QMessageBox,
    QMainWindow,
    QApplication,
    QTableWidgetItem,
    QTextEdit,
)
from PySide6.QtGui import QTextOption, QFont
from PySide6.QtCore import Signal, QObject

from robotinomanager.robotinomanager import RobotinoManager
from commandserver.robotinoserver import RobotinoServer
from commandserver.commandserver import CommandServer
from mescommunicator.mesclient import MESClient
from frontend.ui_form import Ui_MainWindow
from conf import appLogger, rosLogger, log_formatter_ros, log_formatter_app, IP_FLEETIAS


class MainWindow(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        ##############################################
        # --------------------- Setup UI -------------------------
        ##############################################
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        #  ----------- Connect callback functions --------------
        # Start/Stop servers
        self.ui.buttonStartCommandServer.clicked.connect(self.startCommandServer)
        self.ui.buttonStopCommandServer.clicked.connect(self.stopCommandServer)
        self.ui.buttonStartMesClient.clicked.connect(self.startMesClient)
        self.ui.buttonStopMesClient.clicked.connect(self.stopMesClient)
        # Manual Operations
        self.ui.buttonUndock.clicked.connect(self.manualUndock)
        self.ui.buttonDock.clicked.connect(self.manualDock)
        self.ui.buttonUnloadCarrier.clicked.connect(self.manualUnloadCarrier)
        self.ui.buttonLoadCarrier.clicked.connect(self.manualLoadCarrier)
        self.ui.buttonDriveTo.clicked.connect(self.manualDriveTo)
        self.ui.buttonDriveToPos.clicked.connect(self.manualDriveToPos)
        self.ui.buttonSetAutomatic.clicked.connect(self.setAutoMode)
        self.ui.buttonSetManual.clicked.connect(self.setManualMode)
        self.ui.buttonSetDockingPos.clicked.connect(self.setDockingPos)
        self.ui.buttonEndTask.clicked.connect(self.endTask)
        # ROS
        self.ui.useCustomNavigationCB.clicked.connect(self.readUseROS)
        self.ui.pushButton_offset.clicked.connect(self.sendCommandAddOffset)
        self.ui.pushButton_feature.clicked.connect(self.sendCommandActivateFeature)
        #  ---------------- Set values in GUI ---------------------
        # Add items to Comboboxes
        self.ui.feature_comboBox.addItems(["LIDAR"])
        self.ui.feature_comboBox.setCurrentIndex(0)
        self.ui.topic_comboBox.addItems(["Localization"])
        self.ui.topic_comboBox.setCurrentIndex(0)
        # Set default values
        self.ui.inputRobtinoId.setValue(7)
        self.ui.buttonStopCommandServer.setEnabled(False)
        self.ui.buttonStopMesClient.setEnabled(False)
        self.ui.pushButton_offset.setEnabled(False)
        self.ui.pushButton_feature.setEnabled(False)
        self.setEnabledManualButtons(False)

        ##############################################
        # ---------------- Setup Application --------------------
        ##############################################
        self.robotinoServer = RobotinoServer()
        self.commandServer = CommandServer()
        self.mesClient = MESClient()
        self.robotinoManager = RobotinoManager(self.robotinoServer, self.mesClient)
        self.robotinoServer.setRobotinoManager(self.robotinoManager)
        self.commandServer.setRobotinoManager(self.robotinoManager)
        # Start threads
        self.commandServer.start()
        self.robotinoServer.start()
        self.mesClient.start()
        # Connect callback functions of threads
        self.robotinoServer.errorSignal.connect(self.showErrorDialog)
        self.robotinoServer.stoppedSignal.connect(self.stopCommandServer)
        self.mesClient.stoppedSignal.connect(self.stopMesClient)
        self.robotinoManager.newTaskInfoSignal.connect(self.addTransportTask)
        self.robotinoManager.deleteTaskInfoSignal.connect(self.deleteTransportTask)
        self.robotinoManager.statesRobotinoSignal.connect(self.setStatesRobotino)
        # Data which is being displayed
        self.statesRobotinos = []
        self.transportTasks = set()
        self.useROS = False
        # Setup logging to GUI
        guiLogHandlerROS = GuiLogHandler(self.ui.textEdit_logger)
        guiLogHandlerROS.setFormatter(log_formatter_ros)
        guiLogHandlerApp = GuiLogHandler(self.ui.textEdit_logger)
        guiLogHandlerApp.setFormatter(log_formatter_app)
        rosLogger.addHandler(guiLogHandlerROS)
        appLogger.addHandler(guiLogHandlerApp)

    def closeEvent(self, event):
        self.robotinoManager.stop()
        self.robotinoServer.stopServer()
        self.commandServer.stopServer()
        self.mesClient.stopClient()
        event.accept()

    def fillTableViewRobotinoManager(self):
        """
        Fills out the rows of the tableview of robotinomanager
        """
        self.ui.tableViewRobotinos.setRowCount(0)
        for robotino in self.statesRobotinos:
            # add empty row
            rowPosition = self.ui.tableViewRobotinos.rowCount()
            self.ui.tableViewRobotinos.insertRow(rowPosition)
            # fill row with items
            # id
            self.ui.tableViewRobotinos.setItem(
                rowPosition, 0, QTableWidgetItem(str(robotino.id))
            )
            # mode
            if robotino.autoMode:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 1, QTableWidgetItem("Automated")
                )
            elif robotino.manualMode:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 1, QTableWidgetItem("Manual")
                )
            # Battery
            # Battery has at full charge 12,7 V and two batterys are in series => Full accu has 25.4 V
            # Battery is empty at 11,5 V and two batterys are in series => Full accu has 23.0 V
            # => Voltage drops with 2.4V (1.2V with one battery) from full to empty with linear approximation
            # batterLevel = (25.4 V - current battery voltage )/2.4 (for notation in percentage it has to be multiplied with 100)
            batteryLevel = round((((25.4) - robotino.batteryVoltage) / 2.4) * 100)
            # set batteryLevel to 0% for invalid values e.g. when no battery voltage is given
            if batteryLevel > 100 or batteryLevel < 0:
                batteryLevel = 0
            self.ui.tableViewRobotinos.setItem(
                rowPosition,
                2,
                QTableWidgetItem(str(robotino.batteryVoltage) + " V"),
            )
            # error
            if robotino.laserWarning:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 3, QTableWidgetItem("Laserwarning")
                )
            elif robotino.laserSaftey:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 3, QTableWidgetItem("Laser Saftey")
                )
            elif robotino.errorL2:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 3, QTableWidgetItem("Operational Error")
                )
            else:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 3, QTableWidgetItem("None")
                )
            # state
            if robotino.busy:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 4, QTableWidgetItem("Busy")
                )
            elif not robotino.busy and robotino.errorL2:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 4, QTableWidgetItem("Error")
                )
            elif not robotino.busy and not robotino.errorL2:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 4, QTableWidgetItem("Idle")
                )

    def fillTableViewMES(self):
        """
        Fills out the rows of the tableview of IAS-MES
        """
        self.ui.tableViewMes.setRowCount(0)
        for task in self.transportTasks:
            # add empty row
            rowPosition = self.ui.tableViewMes.rowCount()
            self.ui.tableViewMes.insertRow(rowPosition)
            # fill row with items
            # start
            self.ui.tableViewMes.setItem(rowPosition, 0, QTableWidgetItem(str(task[0])))
            # target
            self.ui.tableViewMes.setItem(rowPosition, 1, QTableWidgetItem(str(task[1])))
            # assigned robotino
            self.ui.tableViewMes.setItem(rowPosition, 2, QTableWidgetItem(str(task[2])))
            # state
            self.ui.tableViewMes.setItem(rowPosition, 3, QTableWidgetItem(task[3]))

    def showErrorDialog(self, errMsg, robotinoId):
        """
        Setup Dialog
        """
        dialog = QMessageBox()
        # set dialog title
        dialog.setWindowTitle("Error")
        # set error message and little description what the user can do
        dialog.setText(errMsg)
        dialog.setInformativeText(
            'Click "Retry" to retry the operation or click "Abort" to abort the operation (Warning: When error occurs on automated operation, the transporttask could get aborted)'
        )
        # set dialog icon
        dialog.setIcon(QMessageBox.Critical)
        # set buttons of dialog
        dialog.setStandardButtons(QMessageBox.Retry | QMessageBox.Abort)

        returnValue = dialog.exec()
        if returnValue == QMessageBox.Retry:
            self.robotinoManager.retryOp(errMsg, robotinoId)

    # -------------------- Callback functions -----------------------------
    def startCommandServer(self):
        """
        Callback function to start commandServer
        """
        appLogger.debug("Starting CommandServer...")
        self.robotinoServer.start()
        self.robotinoManager.start()
        self.ui.buttonStopCommandServer.setEnabled(True)
        self.ui.buttonStartCommandServer.setEnabled(False)
        self.setEnabledManualButtons(True)

    def stopCommandServer(self):
        """
        Callback function to stop commandServer
        """
        appLogger.debug("Stopping CommandServer...")
        self.robotinoServer.stopServer()
        self.robotinoManager.stop()
        self.ui.buttonStopCommandServer.setEnabled(False)
        self.ui.buttonStartCommandServer.setEnabled(True)
        self.setEnabledManualButtons(False)

    def startMesClient(self):
        """
        Callback function to start mesClient
        """
        appLogger.debug("Starting MESClient...")
        self.mesClient.start()
        self.robotinoManager.startAutomatedOperation()
        self.ui.buttonStopMesClient.setEnabled(True)
        self.ui.buttonStartMesClient.setEnabled(False)

    def stopMesClient(self):
        """
        Callback function to stop mesClient
        """
        appLogger.debug("Stopping MESClient...")
        self.mesClient.stopClient()
        self.robotinoManager.stopAutomatedOperation()
        self.ui.buttonStartMesClient.setEnabled(True)
        self.ui.buttonStopMesClient.setEnabled(False)

    def setEnabledManualButtons(self, isEnabled: bool):
        self.ui.buttonLoadCarrier.setEnabled(isEnabled)
        self.ui.buttonUnloadCarrier.setEnabled(isEnabled)
        self.ui.buttonDock.setEnabled(isEnabled)
        self.ui.buttonUndock.setEnabled(isEnabled)
        self.ui.buttonDriveTo.setEnabled(isEnabled)
        self.ui.buttonDriveToPos.setEnabled(isEnabled)
        self.ui.buttonSetAutomatic.setEnabled(isEnabled)
        self.ui.buttonSetManual.setEnabled(isEnabled)
        self.ui.buttonSetDockingPos.setEnabled(isEnabled)
        self.ui.buttonEndTask.setEnabled(isEnabled)

    def manualUndock(self):
        """
        Callback function to manual trigger undocking
        """
        appLogger.debug("Manual send command to robotino to undock")
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            Thread(target=robotino.undock).start()
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def manualDock(self):
        """
        Callback function to manual trigger docking
        """
        target = self.ui.inputResourceId.value()
        appLogger.debug("Manual send command to robotino to dock")
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            Thread(target=robotino.dock, args=[target]).start()
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command becaus robotino is not present"
            )

    def manualUnloadCarrier(self):
        """
        Callback function to manual trigger unloading
        """
        appLogger.debug("Manual send command to robotino to unload carrier")
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            Thread(target=robotino.unloadCarrier).start()
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command becaus robotino is not present"
            )

    def manualLoadCarrier(self):
        """
        Callback function to manual trigger loading
        """
        appLogger.debug("Manual send command to robotino to load carrier")
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            Thread(target=robotino.loadCarrier).start()
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command becaus robotino is not present"
            )

    def manualDriveTo(self):
        """
        Callback function to manual trigger driving to resource
        """
        target = self.ui.inputResourceId.value()
        appLogger.debug(
            "Manual send command to robotino to drive to resource " + str(target)
        )
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            if not self.useROS:
                # Use proprietary Robotino stack
                Thread(target=robotino.driveTo, args=[target]).start()
            else:
                # Use ROS Robotino stack
                Thread(
                    target=self.commandServer.goTo,
                    args=[target, robotino.id, "resource"],
                ).start()
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def manualDriveToPos(self):
        """
        Callback function to manual trigger driving to a coordinate
        """
        x = self.ui.xSpinBox.value()
        y = self.ui.ySpinBox.value()
        appLogger.debug(
            f"Manual send command to robotino to drive to coordinate ({x},{y})"
        )
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            if not self.useROS:
                # Use proprietary Robotino stack
                Thread(target=robotino.driveToCor, args=[(x, y)]).start()
            else:
                # Use ROS Robotino stack
                Thread(
                    target=self.commandServer.goTo,
                    args=[(x, y), robotino.id, "coordinate"],
                ).start()
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def setDockingPos(self):
        """
        Callback function to manual set docking Position of Robotino
        """
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        target = self.ui.inputResourceId.value()
        if robotino != None:
            Thread(target=robotino.setDockingPos, args=[target]).start()
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def endTask(self):
        """
        Callback function to manual end task of Robotino
        """
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            Thread(target=robotino.endTask).start()
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def setAutoMode(self):
        """
        Callback function to manual set robotino to automatic operation
        """
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        Thread(target=robotino.activateAutoMode).start()

    def setManualMode(self):
        """
        Callback function to manual set Robotino to manual operation
        """
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        Thread(target=robotino.activateManualMode).start()

    def readUseROS(self):
        """
        Callback function to use ros
        """
        # self.robotinoManager.setUseOldControlForWholeFleet(
        #     self.ui.useCustomNavigationCB.isChecked()
        # )
        self.useROS = self.ui.useCustomNavigationCB.isChecked()
        if self.ui.useCustomNavigationCB.isChecked():
            self.ui.pushButton_offset.setEnabled(True)
            self.ui.pushButton_feature.setEnabled(True)
        else:
            self.ui.pushButton_offset.setEnabled(False)
            self.ui.pushButton_feature.setEnabled(False)

    def sendCommandAddOffset(self):
        """
        Callback function to send command "AddOffset" to ROS
        """
        topic = self.ui.topic_comboBox.currentText()
        offset = self.ui.offset_value_input.value()
        robotinoId = self.ui.inputRobtinoId.value()
        if robotinoId != 0:
            Thread(
                target=self.robotinoServer.ROSAddOffset,
                args=[topic, offset, robotinoId],
            ).start()
        else:
            Thread(
                target=self.robotinoServer.ROSAddOffset, args=[topic, offset]
            ).start()

    def sendCommandActivateFeature(self):
        """
        Callback function to send command "ActivateFeature" to ROS
        """
        feature = self.ui.feature_comboBox.currentText()
        isEnabled = self.ui.checkBox_feature.isChecked()
        robotinoId = self.ui.inputRobtinoId.value()
        if robotinoId != 0:
            Thread(
                target=self.robotinoServer.ROSActivateFeature,
                args=[feature, isEnabled, robotinoId],
            ).start()
        else:
            Thread(
                target=self.robotinoServer.ROSActivateFeature, args=[feature, isEnabled]
            ).start()

    # ---------------------- Setter ---------------------------

    def setStatesRobotino(self, statesRobotino):
        self.statesRobotinos = statesRobotino
        self.fillTableViewRobotinoManager()

    def addTransportTask(self, start: int, target: int, robotinoId: int, state: str):
        self.transportTasks.add((start, target, robotinoId, state))
        self.fillTableViewMES()

    def deleteTransportTask(self, start: int, target: int, robotinoId: int, state: str):
        if len(self.transportTasks) != 0:
            transportTaskData = (start, target)
            for task in self.transportTasks:
                currentTaskData = (task[0], task[1])
                if currentTaskData == transportTaskData:
                    self.transportTasks.remove(task)
                    break
        self.fillTableViewMES()


class LogSignal(QObject):
    signal = Signal(str)


class GuiLogHandler(logging.Handler):
    def __init__(self, parent: QTextEdit, fontSize=12, *args, **kwargs):
        super(GuiLogHandler, self).__init__(*args, **kwargs)
        self.widget = parent
        # Disable the editability of the edittextbox
        self.widget.setReadOnly(True)
        # Set text Size
        font = QFont()
        font.setPointSize(fontSize)
        self.widget.setFont(font)
        # Set textwrap modes
        self.widget.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)
        self.widget.setWordWrapMode(QTextOption.WrapMode.WrapAtWordBoundaryOrAnywhere)
        # Signal used so Handler is thread safe
        self.signaller = LogSignal()
        self.signaller.signal.connect(self.widget.append)

    def emit(self, record):
        msg = self.format(record)
        self.signaller.signal.emit(msg)


if __name__ == "__main__":
    """Runs GUI"""
    sys._excepthook = sys.excepthook

    def exception_hook(exctype, value, traceback):
        print(exctype, value, traceback)
        sys._excepthook(exctype, value, traceback)
        sys.exit(1)

    sys.excepthook = exception_hook
    appLogger.setLevel(logging.INFO)
    app = QApplication(sys.argv)
    widget = MainWindow()
    widget.showMaximized()
    sys.exit(app.exec())
