"""
Filename: mainwindow.py
Version name: 1.0, 2021-07-22
Short description: callback functions for button presses. These are defined here so it wont get deleted
if mainwindow.py is regenerated by pyqt5-tools

(C) 2003-2021 IAS, Universitaet Stuttgart

"""

import sys
import logging
from PySide6.QtWidgets import (
    QMessageBox,
    QMainWindow,
    QApplication,
    QTableWidgetItem,
    QTextEdit,
)
from PySide6.QtGui import QTextOption, QFont
from PySide6.QtCore import Signal, QObject

from robotinomanager.robotinomanager import RobotinoManager
from commandserver.robotinoserver import RobotinoServer
from commandserver.commandserver import CommandServer
from mescommunicator.mesclient import MESClient
from frontend.ui_form import Ui_MainWindow
from conf import (
    appLogger,
    rosLogger,
    log_formatter_ros,
    log_formatter_app,
)


class MainWindow(QMainWindow):
    def __init__(self, parent=None):
        super().__init__(parent)
        # ui instance
        self.ui = Ui_MainWindow()
        self.ui.setupUi(self)
        # setup instances of all servers and managers
        self.robotinoServer = RobotinoServer()
        self.commandServer = CommandServer()
        self.mesClient = MESClient()
        self.robotinoManager = RobotinoManager(
            robotinoServer=self.robotinoServer, mesClient=self.mesClient, guiManager=self
        )
        self.robotinoServer.setRobotinoManager(self.robotinoManager)
        self.commandServer.setRobotinoManager(self.robotinoManager)
        # Commandserver always runs in background
        self.commandServer.start()

        # data which is being displayed
        self.statesRobotinos = []
        self.transportTasks = set()
        self.useROS = False
        # -------------------- Connect callback functions -----------------
        # Start/Stop servers
        self.ui.buttonStartCommandServer.clicked.connect(self.startCommandServer)
        self.ui.buttonStopCommandServer.clicked.connect(self.stopCommandServer)
        self.ui.buttonStartMesClient.clicked.connect(self.startMesClient)
        self.ui.buttonStopMesClient.clicked.connect(self.stopMesClient)
        # Manual Operations
        self.ui.buttonUndock.clicked.connect(self.manualUndock)
        self.ui.buttonDock.clicked.connect(self.manualDock)
        self.ui.buttonUnloadCarrier.clicked.connect(self.manualUnloadCarrier)
        self.ui.buttonLoadCarrier.clicked.connect(self.manualLoadCarrier)
        self.ui.buttonDriveTo.clicked.connect(self.manualDriveTo)
        self.ui.buttonDriveToPos.clicked.connect(self.manualDriveToPos)
        self.ui.buttonSetAutomatic.clicked.connect(self.setAutoMode)
        self.ui.buttonSetManual.clicked.connect(self.setManualMode)
        self.ui.buttonSetDockingPos.clicked.connect(self.setDockingPos)
        self.ui.buttonEndTask.clicked.connect(self.endTask)
        # ROS
        self.ui.useCustomNavigationCB.clicked.connect(self.readUseROS)
        self.ui.pushButton_offset.clicked.connect(self.sendCommandAddOffset)
        self.ui.pushButton_feature.clicked.connect(self.sendCommandActivateFeature)
        # From threads
        self.robotinoManager.errorSignal.connect(self.showErrorDialog)
        self.mesClient.stoppedSignal.connect(self.stopMesClient)
        self.robotinoServer.stoppedSignal.connect(self.stopCommandServer)
        # ------------------------ Add items to Comboboxes ------------------------------
        self.ui.feature_comboBox.addItems(["LIDAR"])
        self.ui.feature_comboBox.setCurrentIndex(0)
        self.ui.topic_comboBox.addItems(["Localization"])
        self.ui.topic_comboBox.setCurrentIndex(0)
        # ------------------------ Set default values ---------------------------------------
        self.ui.inputRobtinoId.setValue(7)
        self.ui.buttonStopCommandServer.setEnabled(False)
        self.ui.buttonStopMesClient.setEnabled(False)
        self.ui.pushButton_offset.setEnabled(False)
        self.ui.pushButton_feature.setEnabled(False)
        self.setEnabledManualButtons(False)

        guiLogHandlerROS = GuiLogHandler(self.ui.textEdit_logger)
        guiLogHandlerROS.setFormatter(log_formatter_ros)
        guiLogHandlerApp = GuiLogHandler(self.ui.textEdit_logger)
        guiLogHandlerApp.setFormatter(log_formatter_app)
        rosLogger.addHandler(guiLogHandlerROS)
        appLogger.addHandler(guiLogHandlerApp)

    def closeEvent(self, event):
        self.robotinoServer.stopServer()
        self.commandServer.stopServer()
        self.mesClient.stopClient()
        self.robotinoManager.stop()
        event.accept()

    def fillTableViewRobotinoManager(self):
        """
        Fills out the rows of the tableview of robotinomanager
        """
        self.ui.tableViewRobotinos.setRowCount(0)
        for robotino in self.statesRobotinos:
            # add empty row
            rowPosition = self.ui.tableViewRobotinos.rowCount()
            self.ui.tableViewRobotinos.insertRow(rowPosition)
            # fill row with items
            # id
            self.ui.tableViewRobotinos.setItem(
                rowPosition, 0, QTableWidgetItem(str(robotino.id))
            )
            # mode
            if robotino.autoMode:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 1, QTableWidgetItem("Automated")
                )
            elif robotino.manualMode:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 1, QTableWidgetItem("Manual")
                )
            # Battery
            # Battery has at full charge 12,7 V and two batterys are in series => Full accu has 25.4 V
            # Battery is empty at 11,5 V and two batterys are in series => Full accu has 23.0 V
            # => Voltage drops with 2.4V (1.2V with one battery) from full to empty with linear approximation
            # batterLevel = (25.4 V - current battery voltage )/2.4 (for notation in percentage it has to be multiplied with 100)
            batteryLevel = round((((25.4) - robotino.batteryVoltage) / 2.4) * 100)
            # set batteryLevel to 0% for invalid values e.g. when no battery voltage is given
            if batteryLevel > 100 or batteryLevel < 0:
                batteryLevel = 0
            self.ui.tableViewRobotinos.setItem(
                rowPosition,
                2,
                QTableWidgetItem(str(robotino.batteryVoltage) + " V"),
            )
            # error
            if robotino.laserWarning:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 3, QTableWidgetItem("Laserwarning")
                )
            elif robotino.laserSaftey:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 3, QTableWidgetItem("Laser Saftey")
                )
            elif robotino.errorL2:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 3, QTableWidgetItem("Operational Error")
                )
            else:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 3, QTableWidgetItem("None")
                )
            # state
            if robotino.busy:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 4, QTableWidgetItem("Busy")
                )
            elif not robotino.busy and robotino.errorL2:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 4, QTableWidgetItem("Error")
                )
            elif not robotino.busy and not robotino.errorL2:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 4, QTableWidgetItem("Idle")
                )

    def fillTableViewMES(self):
        """
        Fills out the rows of the tableview of IAS-MES
        """
        self.ui.tableViewMes.setRowCount(0)
        for task in self.transportTasks:
            # add empty row
            rowPosition = self.ui.tableViewMes.rowCount()
            self.ui.tableViewMes.insertRow(rowPosition)
            # fill row with items
            # start
            self.ui.tableViewMes.setItem(rowPosition, 0, QTableWidgetItem(str(task[0])))
            # target
            self.ui.tableViewMes.setItem(rowPosition, 1, QTableWidgetItem(str(task[1])))
            # assigned robotino
            self.ui.tableViewMes.setItem(rowPosition, 2, QTableWidgetItem(str(task[2])))
            # state
            self.ui.tableViewMes.setItem(rowPosition, 3, QTableWidgetItem(task[3]))

    def showErrorDialog(self, errMsg, robotinoId):
        """
        Setup Dialog
        """
        dialog = QMessageBox()
        # set dialog title
        dialog.setWindowTitle("Error")
        # set error message and little description what the user can do
        dialog.setText(errMsg)
        dialog.setInformativeText(
            'Click "Retry" to retry the operation or click "Abort" to abort the operation (Warning: When error occurs on automated operation, the transporttask could get aborted)'
        )
        # set dialog icon
        dialog.setIcon(QMessageBox.Critical)
        # set buttons of dialog
        dialog.setStandardButtons(QMessageBox.Retry | QMessageBox.Abort)

        returnValue = dialog.exec()
        if returnValue == QMessageBox.Retry:
            self.robotinoManager.retryOp(errMsg, robotinoId)

    # -------------------- Callback functions -----------------------------
    def startCommandServer(self):
        """
        Callback function to start commandServer
        """
        appLogger.debug("Starting CommandServer...")
        self.robotinoServer.start()
        self.robotinoManager.start()
        self.ui.buttonStopCommandServer.setEnabled(True)
        self.ui.buttonStartCommandServer.setEnabled(False)
        self.setEnabledManualButtons(True)

    def stopCommandServer(self):
        """
        Callback function to stop commandServer
        """
        appLogger.debug("Stopping CommandServer...")
        self.robotinoServer.stopServer()
        self.robotinoManager.stop()
        self.ui.buttonStopCommandServer.setEnabled(False)
        self.ui.buttonStartCommandServer.setEnabled(True)
        self.setEnabledManualButtons(False)

    def startMesClient(self):
        """
        Callback function to start mesClient
        """
        appLogger.debug("Starting MESClient...")
        self.mesClient.start()
        self.robotinoManager.startAutomatedOperation()
        self.ui.buttonStopMesClient.setEnabled(True)
        self.ui.buttonStartMesClient.setEnabled(False)

    def stopMesClient(self):
        """
        Callback function to stop mesClient
        """
        appLogger.debug("Stopping MESClient...")
        self.mesClient.stopClient()
        self.robotinoManager.stopAutomatedOperation()
        self.ui.buttonStartMesClient.setEnabled(True)
        self.ui.buttonStopMesClient.setEnabled(False)

    def setEnabledManualButtons(self, isEnabled: bool):
        self.ui.buttonLoadCarrier.setEnabled(isEnabled)
        self.ui.buttonUnloadCarrier.setEnabled(isEnabled)
        self.ui.buttonDock.setEnabled(isEnabled)
        self.ui.buttonUndock.setEnabled(isEnabled)
        self.ui.buttonDriveTo.setEnabled(isEnabled)
        self.ui.buttonDriveToPos.setEnabled(isEnabled)
        self.ui.buttonSetAutomatic.setEnabled(isEnabled)
        self.ui.buttonSetManual.setEnabled(isEnabled)
        self.ui.buttonSetDockingPos.setEnabled(isEnabled)
        self.ui.buttonEndTask.setEnabled(isEnabled)

    def manualUndock(self):
        """
        Callback function to manual trigger undocking
        """
        appLogger.debug("Manual send command to robotino to undock")
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            robotino.undock()
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def manualDock(self):
        """
        Callback function to manual trigger docking
        """
        target = self.ui.inputResourceId.value()
        appLogger.debug("Manual send command to robotino to dock")
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            robotino.dock(target)
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command becaus robotino is not present"
            )

    def manualUnloadCarrier(self):
        """
        Callback function to manual trigger unloading
        """
        appLogger.debug("Manual send command to robotino to unload carrier")
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            robotino.unloadCarrier()
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command becaus robotino is not present"
            )

    def manualLoadCarrier(self):
        """
        Callback function to manual trigger loading
        """
        appLogger.debug("Manual send command to robotino to load carrier")
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            robotino.loadCarrier()
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command becaus robotino is not present"
            )

    def manualDriveTo(self):
        """
        Callback function to manual trigger driving to resource
        """
        target = self.ui.inputResourceId.value()
        appLogger.debug(
            "Manual send command to robotino to drive to resource " + str(target)
        )
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            if not self.useROS:
                # Use proprietary Robotino stack
                robotino.driveTo(target)
            else:
                # Use ROS Robotino stack
                robotino.driveToROS(target)
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def manualDriveToPos(self):
        """
        Callback function to manual trigger driving to a coordinate
        """
        x = self.ui.xSpinBox.value()
        y = self.ui.ySpinBox.value()
        appLogger.debug(
            "Manual send command to robotino to drive to coordinate ({x},{y})"
        )
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            if not self.useROS:
                # Use proprietary Robotino stack
                robotino.driveToCor((x, y))
            else:
                # Use ROS Robotino stack
                robotino.driveToCorROS((x, y))
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def setDockingPos(self):
        """
        Callback function to manual set docking Position of Robotino
        """
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        target = self.ui.inputResourceId.value()
        if robotino != None:
            robotino.setDockingPos(target)
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def endTask(self):
        """
        Callback function to manual end task of Robotino
        """
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            robotino.endTask()
        else:
            appLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def setAutoMode(self):
        """
        Callback function to manual set robotino to automatic operation
        """
        for robotino in self.statesRobotinos:
            if robotino.id == self.ui.inputRobtinoId.value():
                robotino.activateAutoMode()

    def setManualMode(self):
        """
        Callback function to manual set Robotino to manual operation
        """
        for robotino in self.statesRobotinos:
            if robotino.id == self.ui.inputRobtinoId.value():
                robotino.activateManualMode()

    def readUseROS(self):
        """
        Callback function to use ros
        """
        # self.robotinoManager.setUseOldControlForWholeFleet(
        #     self.ui.useCustomNavigationCB.isChecked()
        # )
        self.useROS = self.ui.useCustomNavigationCB.isChecked()
        if self.ui.useCustomNavigationCB.isChecked():
            self.ui.pushButton_offset.setEnabled(True)
            self.ui.pushButton_feature.setEnabled(True)
        else:
            self.ui.pushButton_offset.setEnabled(False)
            self.ui.pushButton_feature.setEnabled(False)

    def sendCommandAddOffset(self):
        """
        Callback function to send command "AddOffset" to ROS
        """
        topic = self.ui.topic_comboBox.currentText()
        offset = self.ui.offset_value_input.value()
        robotinoId = self.ui.inputRobtinoId.value()
        if robotinoId != 0:
            self.robotinoServer.ROSAddOffset(
                name=topic, offset=offset, resourceId=robotinoId
            )
        else:
            self.robotinoServer.ROSAddOffset(name=topic, offset=offset)

    def sendCommandActivateFeature(self):
        """
        Callback function to send command "ActivateFeature" to ROS
        """
        feature = self.ui.feature_comboBox.currentText()
        isEnabled = self.ui.checkBox_feature.isChecked()
        robotinoId = self.ui.inputRobtinoId.value()
        if robotinoId != 0:
            self.robotinoServer.ROSActivateFeature(
                feature=feature, value=isEnabled, resourceId=robotinoId
            )
        else:
            self.robotinoServer.ROSActivateFeature(feature=feature, value=isEnabled)

    # ---------------------- Setter ---------------------------

    def setStatesRobotino(self, statesRobotino):
        self.statesRobotinos = statesRobotino
        self.fillTableViewRobotinoManager()

    def addTransportTask(self, transportTask):
        self.transportTasks.add(transportTask)
        self.fillTableViewMES()

    def deleteTransportTask(self, transportTask):
        if len(self.transportTasks) != 0:
            transportTaskData = (transportTask[0], transportTask[1])
            for task in self.transportTasks:
                currentTaskData = (task[0], task[1])
                if currentTaskData == transportTaskData:
                    self.transportTasks.remove(task)
                    break
        self.fillTableViewMES()


class LogSignal(QObject):
    signal = Signal(str)


class GuiLogHandler(logging.Handler):
    def __init__(self, parent: QTextEdit, fontSize=12, *args, **kwargs):
        super(GuiLogHandler, self).__init__(*args, **kwargs)
        self.widget = parent
        # Disable the editability of the edittextbox
        self.widget.setReadOnly(True)
        # Set text Size
        font = QFont()
        font.setPointSize(fontSize)
        self.widget.setFont(font)
        # Set textwrap modes
        self.widget.setLineWrapMode(QTextEdit.LineWrapMode.WidgetWidth)
        self.widget.setWordWrapMode(QTextOption.WrapMode.WrapAtWordBoundaryOrAnywhere)
        # Signal used so Handkler is thread safe
        self.signaller = LogSignal()
        self.signaller.signal.connect(self.widget.append)

    def emit(self, record):
        msg = self.format(record)
        self.signaller.signal.emit(msg)


if __name__ == "__main__":
    """Runs GUI"""
    app = QApplication(sys.argv)
    widget = MainWindow()
    widget.showMaximized()
    sys.exit(app.exec())
