"""
Filename: guimanager.py
Version name: 1.0, 2021-07-22
Short description: callback functions for button presses. These are defined here so it wont get deleted
if mainwindow.py is regenerated by pyqt5-tools

(C) 2003-2021 IAS, Universitaet Stuttgart

"""

import sys
import time

from PyQt5 import QtGui, QtWidgets
from PyQt5.QtWidgets import QMessageBox  # nopep8

sys.path.append(".")  # nopep8
sys.path.append("..")  # nopep8

from robotinomanager.robotinomanager import RobotinoManager  # nopep8
from commandserver.commandserver import CommandServer  # nopep8
from mescommunicator.mesclient import MESClient  # nopep8
from threading import Thread
from conf import errLogger, USEROSSYSTEM


class GUIManager(object):
    def __init__(self, ui):
        # ui instance
        self.ui = ui
        # setup instances of all servers and managers
        self.commandServer = CommandServer()
        self.mesClient = MESClient()
        self.robotinoManager = RobotinoManager(
            commandServer=self.commandServer, mesClient=self.mesClient, guiManager=self
        )
        self.commandServer.setRobotinoManager(self.robotinoManager)
        # data which is being displayed
        self.statesRobotinos = []
        self.transportTasks = set()
        self.useROS = False

    def __del__(self):
        self.commandServer.stopServer()
        self.mesClient.stopClient()

    def connectCallbackFunction(self):
        """
        Connect all buttons from ui with callback functions
        """
        # ---------------- Start/Stop servers -------------------------------
        self.ui.buttonStartCommandServer.clicked.connect(self.startCommandServer)
        self.ui.buttonStopCommandServer.clicked.connect(self.stopCommandServer)
        self.ui.buttonStartMesClient.clicked.connect(self.startMesClient)
        self.ui.buttonStopMesClient.clicked.connect(self.stopMesClient)

        # ---------------- Manual Operations ----------------------------
        self.ui.buttonUndock.clicked.connect(self.manualUndock)
        self.ui.buttonDock.clicked.connect(self.manualDock)
        self.ui.buttonUnloadCarrier.clicked.connect(self.manualUnloadCarrier)
        self.ui.buttonLoadCarrier.clicked.connect(self.manualLoadCarrier)
        self.ui.buttonDriveTo.clicked.connect(self.manualDriveTo)
        self.ui.buttonSetAutomatic.clicked.connect(self.setAutoMode)
        self.ui.buttonSetManual.clicked.connect(self.setManualMode)
        self.ui.buttonSetDockingPos.clicked.connect(self.setDockingPos)
        self.ui.buttonEndTask.clicked.connect(self.endTask)

        # ------------------------------ ROS ------------------------------------
        self.ui.useCustomNavigationCB.clicked.connect(self.readUseCustomNavigation)
        self.ui.pushButton_offset.clicked.connect(self.sendCommandAddOffset)
        self.ui.pushButton_feature.clicked.connect(self.sendCommandActivateFeature)

    def addComboBoxItems(self):
        """
        Fills the comboboxes in the ui with items
        """
        self.ui.feature_comboBox.addItems(["LIDAR"])
        self.ui.topic_comboBox.addItems(["Localization"])

    def fillTableViewRobotinoManager(self):
        """
        Fills out the rows of the tableview of robotinomanager
        """
        self.ui.tableViewRobotinos.setRowCount(0)
        for robotino in self.statesRobotinos:
            # add empty row
            rowPosition = self.ui.tableViewRobotinos.rowCount()
            self.ui.tableViewRobotinos.insertRow(rowPosition)
            # fill row with items
            # id
            self.ui.tableViewRobotinos.setItem(
                rowPosition, 0, QtWidgets.QTableWidgetItem(str(robotino.id))
            )
            # mode
            if robotino.autoMode:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 1, QtWidgets.QTableWidgetItem("Automated")
                )
            elif robotino.manualMode:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 1, QtWidgets.QTableWidgetItem("Manual")
                )
            # Battery
            # Battery has at full charge 12,7 V and two batterys are in series => Full accu has 25.4 V
            # Battery is empty at 11,5 V and two batterys are in series => Full accu has 23.0 V
            # => Voltage drops with 2.4V (1.2V with one battery) from full to empty with linear approximation
            # batterLevel = (25.4 V - current battery voltage )/2.4 (for notation in percentage it has to be multiplied with 100)
            batteryLevel = round((((25.4) - robotino.batteryVoltage) / 2.4) * 100)
            # set batteryLevel to 0% for invalid values e.g. when no battery voltage is given
            if batteryLevel > 100 or batteryLevel < 0:
                batteryLevel = 0
            self.ui.tableViewRobotinos.setItem(
                rowPosition,
                2,
                QtWidgets.QTableWidgetItem(str(robotino.batteryVoltage) + " V"),
            )
            # error
            if robotino.laserWarning:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 3, QtWidgets.QTableWidgetItem("Laserwarning")
                )
            elif robotino.laserSaftey:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 3, QtWidgets.QTableWidgetItem("Laser Saftey")
                )
            elif robotino.errorL2:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 3, QtWidgets.QTableWidgetItem("Operational Error")
                )
            else:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 3, QtWidgets.QTableWidgetItem("None")
                )
            # state
            if robotino.busy:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 4, QtWidgets.QTableWidgetItem("Busy")
                )
            elif not robotino.busy and robotino.errorL2:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 4, QtWidgets.QTableWidgetItem("Error")
                )
            elif not robotino.busy and not robotino.errorL2:
                self.ui.tableViewRobotinos.setItem(
                    rowPosition, 4, QtWidgets.QTableWidgetItem("Idle")
                )

    def fillTableViewMES(self):
        """
        Fills out the rows of the tableview of IAS-MES
        """
        self.ui.tableViewMes.setRowCount(0)
        for task in self.transportTasks:
            # add empty row
            rowPosition = self.ui.tableViewMes.rowCount()
            self.ui.tableViewMes.insertRow(rowPosition)
            # fill row with items
            # start
            self.ui.tableViewMes.setItem(
                rowPosition, 0, QtWidgets.QTableWidgetItem(str(task[0]))
            )
            # target
            self.ui.tableViewMes.setItem(
                rowPosition, 1, QtWidgets.QTableWidgetItem(str(task[1]))
            )
            # assigned robotino
            self.ui.tableViewMes.setItem(
                rowPosition, 2, QtWidgets.QTableWidgetItem(str(task[2]))
            )
            # state
            self.ui.tableViewMes.setItem(
                rowPosition, 3, QtWidgets.QTableWidgetItem(task[3])
            )

    def showErrorDialog(self, errMsg, robotinoId, callbackFunc):
        """
        Setup Dialog
        """
        dialog = QtWidgets.QMessageBox()
        # set dialog title
        dialog.setWindowTitle("Error")
        # set error message and little description what the user can do
        dialog.setText(errMsg)
        dialog.setInformativeText(
            'Click "Retry" to retry the operation or click "Abort" to abort the operation (Warning: When error occurs on automated operation, the transporttask could get aborted)'
        )
        # set dialog icon
        dialog.setIcon(QMessageBox.Critical)
        # set buttons of dialog
        dialog.setStandardButtons(QMessageBox.Retry | QMessageBox.Abort)
        dialog.buttonClicked.connect(
            lambda: callbackFunc(errorMsg=errMsg, robotinoId=robotinoId)
        )

        x = dialog.exec_()

    # -------------------- Callback functions -----------------------------
    def startCommandServer(self):
        """
        Callback function to start commandServer
        """
        print("[FLEETIAS] Starting CommandServer...")
        self.commandServer.runServer()

    def stopCommandServer(self):
        """
        Callback function to stop commandServer
        """
        print("[FLEETIAS] Stopping CommandServer...")
        self.commandServer.stopServer()

    def startMesClient(self):
        """
        Callback function to start mesClient
        """
        print("[FLEETIAS] Starting MESClient...")
        Thread(target=self.mesClient.run).start()
        Thread(target=self.robotinoManager.startAutomatedOperation).start()

    def stopMesClient(self):
        """
        Callback function to stop mesClient
        """
        print("[FLEETIAS] Stopping MESClient...")
        self.mesClient.stopClient()
        Thread(target=self.robotinoManager.stopAutomatedOperation).start()

    def manualUndock(self):
        """
        Callback function to manual trigger undocking
        """
        print("[FLEETIAS] Manual send command to robotino to undock")
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            robotino.undock()
        else:
            errLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def manualDock(self):
        """
        Callback function to manual trigger docking
        """
        target = self.ui.inputResourceId.value()
        print("[FLEETIAS] Manual send command to robotino to dock")
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            robotino.dock(target)
        else:
            errLogger.error(
                "[FLEETIAS] Couldnt execute command becaus robotino is not present"
            )

    def manualUnloadCarrier(self):
        """
        Callback function to manual trigger unloading
        """
        print("[FLEETIAS] Manual send command to robotino to unload carrier")
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            robotino.unloadCarrier()
        else:
            errLogger.error(
                "[FLEETIAS] Couldnt execute command becaus robotino is not present"
            )

    def manualLoadCarrier(self):
        """
        Callback function to manual trigger loading
        """
        print("[FLEETIAS] Manual send command to robotino to load carrier")
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            robotino.loadCarrier()
        else:
            errLogger.error(
                "[FLEETIAS] Couldnt execute command becaus robotino is not present"
            )

    def manualDriveTo(self):
        """
        Callback function to manual trigger driving to resource
        """
        target = self.ui.inputResourceId.value()
        print(
            "[FLEETIAS] Manual send command to robotino to drive to resource "
            + str(target)
        )
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            if not self.useROS:
                robotino.driveTo(target)
            else:
                robotino.driveToROS(target)
        else:
            errLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def setDockingPos(self):
        """
        Callback function to manual set docking Position of Robotino
        """
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        target = self.ui.inputResourceId.value()
        if robotino != None:
            robotino.setDockingPos(target)
        else:
            errLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def endTask(self):
        """
        Callback function to manual end task of Robotino
        """
        robotino = self.robotinoManager.getRobotino(self.ui.inputRobtinoId.value())
        if robotino != None:
            robotino.endTask()
        else:
            errLogger.error(
                "[FLEETIAS] Couldnt execute command because robotino is not present"
            )

    def setAutoMode(self):
        """
        Callback function to manual set robotino to automatic operation
        """
        for robotino in self.statesRobotinos:
            if robotino.id == self.ui.inputRobtinoId.value():
                robotino.activateAutoMode()

    def setManualMode(self):
        """
        Callback function to manual set Robotino to manual operation
        """
        for robotino in self.statesRobotinos:
            if robotino.id == self.ui.inputRobtinoId.value():
                robotino.activateManualMode()

    def readUseCustomNavigation(self):
        """
        Callback function to use ros
        """
        # self.robotinoManager.setUseOldControlForWholeFleet(
        #     self.ui.useCustomNavigationCB.isChecked()
        # )
        self.useROS = self.ui.useCustomNavigationCB.isChecked()

    def sendCommandAddOffset(self):
        """
        Callback function to send command "AddOffset" to ROS
        """
        topic = self.ui.topic_comboBox.currentText()
        offset = self.ui.offset_value_input.value()
        robotinoId = self.ui.inputRobtinoId.value()
        if robotinoId != 0:
            self.commandServer.ROSAddOffset(
                name=topic, offset=offset, resourceId=robotinoId
            )
        else:
            self.commandServer.ROSAddOffset(name=topic, offset=offset)

    def sendCommandActivateFeature(self):
        """
        Callback function to send command "ActivateFeature" to ROS
        """
        feature = self.ui.feature_comboBox.currentText()
        isEnabled = self.ui.checkBox_feature.isChecked()
        robotinoId = self.ui.inputRobtinoId.value()
        if robotinoId != 0:
            self.commandServer.ROSActivateFeature(
                feature=feature, value=isEnabled, resourceId=robotinoId
            )
        else:
            self.commandServer.ROSActivateFeature(feature=feature, value=isEnabled)

    # ---------------------- Setter ---------------------------

    def setStatesRobotino(self, statesRobotino):
        self.statesRobotinos = statesRobotino
        self.fillTableViewRobotinoManager()

    def addTransportTask(self, transportTask):
        self.transportTasks.add(transportTask)
        self.fillTableViewMES()

    def deleteTransportTask(self, transportTask):
        if len(self.transportTasks) != 0:
            transportTaskData = (transportTask[0], transportTask[1])
            for task in self.transportTasks:
                currentTaskData = (task[0], task[1])
                if currentTaskData == transportTaskData:
                    self.transportTasks.remove(task)
                    break
        self.fillTableViewMES()
